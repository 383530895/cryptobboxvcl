(******************************************************)
(*                                                    *)
(*            EldoS SecureBlackbox Library            *)
(*                                                    *)
(*      Copyright (c) 2002-2014 EldoS Corporation     *)
(*           http://www.secureblackbox.com            *)
(*                                                    *)
(******************************************************)

{$i SecBbox.inc}

unit SBAES;

interface

uses
  SBTypes,
  SBUtils;


const
  TAESBufferSize = 16;

type
  TAESBuffer =  array[0..15] of byte;
  PAESBuffer = ^TAESBuffer;

  TAESKey128 =  array[0..15] of byte;
  TAESExpandedKey128 = array[0..43] of longword;
  PAESKey128 = ^TAESKey128;
  PAESExpandedKey128 = ^TAESExpandedKey128;

  TAESKey192 =  array[0..23] of byte;
  TAESExpandedKey192 = array[0..53] of longword;
  PAESKey192 = ^TAESKey192;
  PAESExpandedKey192 = ^TAESExpandedKey192;

  TAESKey256 =  array[0..31] of byte;
  TAESExpandedKey256 = array[0..63] of longword;
  PAESKey256 = ^TAESKey256;
  PAESExpandedKey256 = ^TAESExpandedKey256;

// Key expansion routines
procedure ExpandKeyForEncryption128(const Key:   TAESKey128  ;
  out ExpandedKey: TAESExpandedKey128);  overload; procedure ExpandKeyForEncryption192(const Key:   TAESKey192  ;
  out ExpandedKey: TAESExpandedKey192);  overload; procedure ExpandKeyForEncryption256(const Key:   TAESKey256  ;
  out ExpandedKey: TAESExpandedKey256);  overload; procedure ExpandKeyForDecryption128(var ExpandedKey: TAESExpandedKey128);  overload; procedure ExpandKeyForDecryption192(var ExpandedKey: TAESExpandedKey192);  overload; procedure ExpandKeyForDecryption256(var ExpandedKey: TAESExpandedKey256);  overload; 
// Block processing routines
procedure Encrypt128(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey128;
  out OutBuf:  TAESBuffer );  overload; procedure Encrypt192(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey192;
  out OutBuf:  TAESBuffer );  overload; procedure Encrypt256(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey256;
  out OutBuf:  TAESBuffer );  overload; procedure Decrypt128(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey128;
  out OutBuf:  TAESBuffer );  overload; procedure Decrypt192(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey192;
  out OutBuf:  TAESBuffer );  overload; procedure Decrypt256(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey256;
  out OutBuf:  TAESBuffer );  overload; 
// Implementations for faster calls from SBSymemtricCrypto
procedure Encrypt128(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey128);  overload; 
procedure Encrypt192(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey192);  overload; 
procedure Encrypt256(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey256);  overload; 
procedure Decrypt128(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey128);  overload; 
procedure Decrypt192(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey192);  overload; 
procedure Decrypt256(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey256);  overload; 

implementation

const
  Rcon: array[1..30] of longword =
     ( 
    $00000001, $00000002, $00000004, $00000008, $00000010, $00000020,
    $00000040, $00000080, $0000001B, $00000036, $0000006C, $000000D8,
    $000000AB, $0000004D, $0000009A, $0000002F, $0000005E, $000000BC,
    $00000063, $000000C6, $00000097, $00000035, $0000006A, $000000D4,
    $000000B3, $0000007D, $000000FA, $000000EF, $000000C5, $00000091
     ) ;

  LastForwardTable: array[0..255] of longword =
   ( 
    $00000063, $0000007C, $00000077, $0000007B, $000000F2, $0000006B,
    $0000006F, $000000C5, $00000030, $00000001, $00000067, $0000002B,
    $000000FE, $000000D7, $000000AB, $00000076, $000000CA, $00000082,
    $000000C9, $0000007D, $000000FA, $00000059, $00000047, $000000F0,
    $000000AD, $000000D4, $000000A2, $000000AF, $0000009C, $000000A4,
    $00000072, $000000C0, $000000B7, $000000FD, $00000093, $00000026,
    $00000036, $0000003F, $000000F7, $000000CC, $00000034, $000000A5,
    $000000E5, $000000F1, $00000071, $000000D8, $00000031, $00000015,
    $00000004, $000000C7, $00000023, $000000C3, $00000018, $00000096,
    $00000005, $0000009A, $00000007, $00000012, $00000080, $000000E2,
    $000000EB, $00000027, $000000B2, $00000075, $00000009, $00000083,
    $0000002C, $0000001A, $0000001B, $0000006E, $0000005A, $000000A0,
    $00000052, $0000003B, $000000D6, $000000B3, $00000029, $000000E3,
    $0000002F, $00000084, $00000053, $000000D1, $00000000, $000000ED,
    $00000020, $000000FC, $000000B1, $0000005B, $0000006A, $000000CB,
    $000000BE, $00000039, $0000004A, $0000004C, $00000058, $000000CF,
    $000000D0, $000000EF, $000000AA, $000000FB, $00000043, $0000004D,
    $00000033, $00000085, $00000045, $000000F9, $00000002, $0000007F,
    $00000050, $0000003C, $0000009F, $000000A8, $00000051, $000000A3,
    $00000040, $0000008F, $00000092, $0000009D, $00000038, $000000F5,
    $000000BC, $000000B6, $000000DA, $00000021, $00000010, $000000FF,
    $000000F3, $000000D2, $000000CD, $0000000C, $00000013, $000000EC,
    $0000005F, $00000097, $00000044, $00000017, $000000C4, $000000A7,
    $0000007E, $0000003D, $00000064, $0000005D, $00000019, $00000073,
    $00000060, $00000081, $0000004F, $000000DC, $00000022, $0000002A,
    $00000090, $00000088, $00000046, $000000EE, $000000B8, $00000014,
    $000000DE, $0000005E, $0000000B, $000000DB, $000000E0, $00000032,
    $0000003A, $0000000A, $00000049, $00000006, $00000024, $0000005C,
    $000000C2, $000000D3, $000000AC, $00000062, $00000091, $00000095,
    $000000E4, $00000079, $000000E7, $000000C8, $00000037, $0000006D,
    $0000008D, $000000D5, $0000004E, $000000A9, $0000006C, $00000056,
    $000000F4, $000000EA, $00000065, $0000007A, $000000AE, $00000008,
    $000000BA, $00000078, $00000025, $0000002E, $0000001C, $000000A6,
    $000000B4, $000000C6, $000000E8, $000000DD, $00000074, $0000001F,
    $0000004B, $000000BD, $0000008B, $0000008A, $00000070, $0000003E,
    $000000B5, $00000066, $00000048, $00000003, $000000F6, $0000000E,
    $00000061, $00000035, $00000057, $000000B9, $00000086, $000000C1,
    $0000001D, $0000009E, $000000E1, $000000F8, $00000098, $00000011,
    $00000069, $000000D9, $0000008E, $00000094, $0000009B, $0000001E,
    $00000087, $000000E9, $000000CE, $00000055, $00000028, $000000DF,
    $0000008C, $000000A1, $00000089, $0000000D, $000000BF, $000000E6,
    $00000042, $00000068, $00000041, $00000099, $0000002D, $0000000F,
    $000000B0, $00000054, $000000BB, $00000016
     ) ;

  F0: array[0..255] of longword =
     ( 
    $A56363C6, $847C7CF8, $997777EE, $8D7B7BF6, $0DF2F2FF, $BD6B6BD6,
    $B16F6FDE, $54C5C591, $50303060, $03010102, $A96767CE, $7D2B2B56,
    $19FEFEE7, $62D7D7B5, $E6ABAB4D, $9A7676EC, $45CACA8F, $9D82821F,
    $40C9C989, $877D7DFA, $15FAFAEF, $EB5959B2, $C947478E, $0BF0F0FB,
    $ECADAD41, $67D4D4B3, $FDA2A25F, $EAAFAF45, $BF9C9C23, $F7A4A453,
    $967272E4, $5BC0C09B, $C2B7B775, $1CFDFDE1, $AE93933D, $6A26264C,
    $5A36366C, $413F3F7E, $02F7F7F5, $4FCCCC83, $5C343468, $F4A5A551,
    $34E5E5D1, $08F1F1F9, $937171E2, $73D8D8AB, $53313162, $3F15152A,
    $0C040408, $52C7C795, $65232346, $5EC3C39D, $28181830, $A1969637,
    $0F05050A, $B59A9A2F, $0907070E, $36121224, $9B80801B, $3DE2E2DF,
    $26EBEBCD, $6927274E, $CDB2B27F, $9F7575EA, $1B090912, $9E83831D,
    $742C2C58, $2E1A1A34, $2D1B1B36, $B26E6EDC, $EE5A5AB4, $FBA0A05B,
    $F65252A4, $4D3B3B76, $61D6D6B7, $CEB3B37D, $7B292952, $3EE3E3DD,
    $712F2F5E, $97848413, $F55353A6, $68D1D1B9, $00000000, $2CEDEDC1,
    $60202040, $1FFCFCE3, $C8B1B179, $ED5B5BB6, $BE6A6AD4, $46CBCB8D,
    $D9BEBE67, $4B393972, $DE4A4A94, $D44C4C98, $E85858B0, $4ACFCF85,
    $6BD0D0BB, $2AEFEFC5, $E5AAAA4F, $16FBFBED, $C5434386, $D74D4D9A,
    $55333366, $94858511, $CF45458A, $10F9F9E9, $06020204, $817F7FFE,
    $F05050A0, $443C3C78, $BA9F9F25, $E3A8A84B, $F35151A2, $FEA3A35D,
    $C0404080, $8A8F8F05, $AD92923F, $BC9D9D21, $48383870, $04F5F5F1,
    $DFBCBC63, $C1B6B677, $75DADAAF, $63212142, $30101020, $1AFFFFE5,
    $0EF3F3FD, $6DD2D2BF, $4CCDCD81, $140C0C18, $35131326, $2FECECC3,
    $E15F5FBE, $A2979735, $CC444488, $3917172E, $57C4C493, $F2A7A755,
    $827E7EFC, $473D3D7A, $AC6464C8, $E75D5DBA, $2B191932, $957373E6,
    $A06060C0, $98818119, $D14F4F9E, $7FDCDCA3, $66222244, $7E2A2A54,
    $AB90903B, $8388880B, $CA46468C, $29EEEEC7, $D3B8B86B, $3C141428,
    $79DEDEA7, $E25E5EBC, $1D0B0B16, $76DBDBAD, $3BE0E0DB, $56323264,
    $4E3A3A74, $1E0A0A14, $DB494992, $0A06060C, $6C242448, $E45C5CB8,
    $5DC2C29F, $6ED3D3BD, $EFACAC43, $A66262C4, $A8919139, $A4959531,
    $37E4E4D3, $8B7979F2, $32E7E7D5, $43C8C88B, $5937376E, $B76D6DDA,
    $8C8D8D01, $64D5D5B1, $D24E4E9C, $E0A9A949, $B46C6CD8, $FA5656AC,
    $07F4F4F3, $25EAEACF, $AF6565CA, $8E7A7AF4, $E9AEAE47, $18080810,
    $D5BABA6F, $887878F0, $6F25254A, $722E2E5C, $241C1C38, $F1A6A657,
    $C7B4B473, $51C6C697, $23E8E8CB, $7CDDDDA1, $9C7474E8, $211F1F3E,
    $DD4B4B96, $DCBDBD61, $868B8B0D, $858A8A0F, $907070E0, $423E3E7C,
    $C4B5B571, $AA6666CC, $D8484890, $05030306, $01F6F6F7, $120E0E1C,
    $A36161C2, $5F35356A, $F95757AE, $D0B9B969, $91868617, $58C1C199,
    $271D1D3A, $B99E9E27, $38E1E1D9, $13F8F8EB, $B398982B, $33111122,
    $BB6969D2, $70D9D9A9, $898E8E07, $A7949433, $B69B9B2D, $221E1E3C,
    $92878715, $20E9E9C9, $49CECE87, $FF5555AA, $78282850, $7ADFDFA5,
    $8F8C8C03, $F8A1A159, $80898909, $170D0D1A, $DABFBF65, $31E6E6D7,
    $C6424284, $B86868D0, $C3414182, $B0999929, $772D2D5A, $110F0F1E,
    $CBB0B07B, $FC5454A8, $D6BBBB6D, $3A16162C
     ) ; 

  FInv0: array[0..255] of longword =
     ( 
    $50A7F451, $5365417E, $C3A4171A, $965E273A, $CB6BAB3B, $F1459D1F,
    $AB58FAAC, $9303E34B, $55FA3020, $F66D76AD, $9176CC88, $254C02F5,
    $FCD7E54F, $D7CB2AC5, $80443526, $8FA362B5, $495AB1DE, $671BBA25,
    $980EEA45, $E1C0FE5D, $02752FC3, $12F04C81, $A397468D, $C6F9D36B,
    $E75F8F03, $959C9215, $EB7A6DBF, $DA595295, $2D83BED4, $D3217458,
    $2969E049, $44C8C98E, $6A89C275, $78798EF4, $6B3E5899, $DD71B927,
    $B64FE1BE, $17AD88F0, $66AC20C9, $B43ACE7D, $184ADF63, $82311AE5,
    $60335197, $457F5362, $E07764B1, $84AE6BBB, $1CA081FE, $942B08F9,
    $58684870, $19FD458F, $876CDE94, $B7F87B52, $23D373AB, $E2024B72,
    $578F1FE3, $2AAB5566, $0728EBB2, $03C2B52F, $9A7BC586, $A50837D3,
    $F2872830, $B2A5BF23, $BA6A0302, $5C8216ED, $2B1CCF8A, $92B479A7,
    $F0F207F3, $A1E2694E, $CDF4DA65, $D5BE0506, $1F6234D1, $8AFEA6C4,
    $9D532E34, $A055F3A2, $32E18A05, $75EBF6A4, $39EC830B, $AAEF6040,
    $069F715E, $51106EBD, $F98A213E, $3D06DD96, $AE053EDD, $46BDE64D,
    $B58D5491, $055DC471, $6FD40604, $FF155060, $24FB9819, $97E9BDD6,
    $CC434089, $779ED967, $BD42E8B0, $888B8907, $385B19E7, $DBEEC879,
    $470A7CA1, $E90F427C, $C91E84F8, $00000000, $83868009, $48ED2B32,
    $AC70111E, $4E725A6C, $FBFF0EFD, $5638850F, $1ED5AE3D, $27392D36,
    $64D90F0A, $21A65C68, $D1545B9B, $3A2E3624, $B1670A0C, $0FE75793,
    $D296EEB4, $9E919B1B, $4FC5C080, $A220DC61, $694B775A, $161A121C,
    $0ABA93E2, $E52AA0C0, $43E0223C, $1D171B12, $0B0D090E, $ADC78BF2,
    $B9A8B62D, $C8A91E14, $8519F157, $4C0775AF, $BBDD99EE, $FD607FA3,
    $9F2601F7, $BCF5725C, $C53B6644, $347EFB5B, $7629438B, $DCC623CB,
    $68FCEDB6, $63F1E4B8, $CADC31D7, $10856342, $40229713, $2011C684,
    $7D244A85, $F83DBBD2, $1132F9AE, $6DA129C7, $4B2F9E1D, $F330B2DC,
    $EC52860D, $D0E3C177, $6C16B32B, $99B970A9, $FA489411, $2264E947,
    $C48CFCA8, $1A3FF0A0, $D82C7D56, $EF903322, $C74E4987, $C1D138D9,
    $FEA2CA8C, $360BD498, $CF81F5A6, $28DE7AA5, $268EB7DA, $A4BFAD3F,
    $E49D3A2C, $0D927850, $9BCC5F6A, $62467E54, $C2138DF6, $E8B8D890,
    $5EF7392E, $F5AFC382, $BE805D9F, $7C93D069, $A92DD56F, $B31225CF,
    $3B99ACC8, $A77D1810, $6E639CE8, $7BBB3BDB, $097826CD, $F418596E,
    $01B79AEC, $A89A4F83, $656E95E6, $7EE6FFAA, $08CFBC21, $E6E815EF,
    $D99BE7BA, $CE366F4A, $D4099FEA, $D67CB029, $AFB2A431, $31233F2A,
    $3094A5C6, $C066A235, $37BC4E74, $A6CA82FC, $B0D090E0, $15D8A733,
    $4A9804F1, $F7DAEC41, $0E50CD7F, $2FF69117, $8DD64D76, $4DB0EF43,
    $544DAACC, $DF0496E4, $E3B5D19E, $1B886A4C, $B81F2CC1, $7F516546,
    $04EA5E9D, $5D358C01, $737487FA, $2E410BFB, $5A1D67B3, $52D2DB92,
    $335610E9, $1347D66D, $8C61D79A, $7A0CA137, $8E14F859, $893C13EB,
    $EE27A9CE, $35C961B7, $EDE51CE1, $3CB1477A, $59DFD29C, $3F73F255,
    $79CE1418, $BF37C773, $EACDF753, $5BAAFD5F, $146F3DDF, $86DB4478,
    $81F3AFCA, $3EC468B9, $2C342438, $5F40A3C2, $72C31D16, $0C25E2BC,
    $8B493C28, $41950DFF, $7101A839, $DEB30C08, $9CE4B4D8, $90C15664,
    $6184CB7B, $70B632D5, $745C6C48, $4257B8D0
     ) ;
  F1: array[0..255] of longword =
     ( 
    $6363C6A5, $7C7CF884, $7777EE99, $7B7BF68D, $F2F2FF0D, $6B6BD6BD,
    $6F6FDEB1, $C5C59154, $30306050, $1010203, $6767CEA9, $2B2B567D,
    $FEFEE719, $D7D7B562, $ABAB4DE6, $7676EC9A, $CACA8F45, $82821F9D,
    $C9C98940, $7D7DFA87, $FAFAEF15, $5959B2EB, $47478EC9, $F0F0FB0B,
    $ADAD41EC, $D4D4B367, $A2A25FFD, $AFAF45EA, $9C9C23BF, $A4A453F7,
    $7272E496, $C0C09B5B, $B7B775C2, $FDFDE11C, $93933DAE, $26264C6A,
    $36366C5A, $3F3F7E41, $F7F7F502, $CCCC834F, $3434685C, $A5A551F4,
    $E5E5D134, $F1F1F908, $7171E293, $D8D8AB73, $31316253, $15152A3F,
    $404080C, $C7C79552, $23234665, $C3C39D5E, $18183028, $969637A1,
    $5050A0F, $9A9A2FB5, $7070E09, $12122436, $80801B9B, $E2E2DF3D,
    $EBEBCD26, $27274E69, $B2B27FCD, $7575EA9F, $909121B, $83831D9E,
    $2C2C5874, $1A1A342E, $1B1B362D, $6E6EDCB2, $5A5AB4EE, $A0A05BFB,
    $5252A4F6, $3B3B764D, $D6D6B761, $B3B37DCE, $2929527B, $E3E3DD3E,
    $2F2F5E71, $84841397, $5353A6F5, $D1D1B968, $0, $EDEDC12C,
    $20204060, $FCFCE31F, $B1B179C8, $5B5BB6ED, $6A6AD4BE, $CBCB8D46,
    $BEBE67D9, $3939724B, $4A4A94DE, $4C4C98D4, $5858B0E8, $CFCF854A,
    $D0D0BB6B, $EFEFC52A, $AAAA4FE5, $FBFBED16, $434386C5, $4D4D9AD7,
    $33336655, $85851194, $45458ACF, $F9F9E910, $2020406, $7F7FFE81,
    $5050A0F0, $3C3C7844, $9F9F25BA, $A8A84BE3, $5151A2F3, $A3A35DFE,
    $404080C0, $8F8F058A, $92923FAD, $9D9D21BC, $38387048, $F5F5F104,
    $BCBC63DF, $B6B677C1, $DADAAF75, $21214263, $10102030, $FFFFE51A,
    $F3F3FD0E, $D2D2BF6D, $CDCD814C, $C0C1814, $13132635, $ECECC32F,
    $5F5FBEE1, $979735A2, $444488CC, $17172E39, $C4C49357, $A7A755F2,
    $7E7EFC82, $3D3D7A47, $6464C8AC, $5D5DBAE7, $1919322B, $7373E695,
    $6060C0A0, $81811998, $4F4F9ED1, $DCDCA37F, $22224466, $2A2A547E,
    $90903BAB, $88880B83, $46468CCA, $EEEEC729, $B8B86BD3, $1414283C,
    $DEDEA779, $5E5EBCE2, $B0B161D, $DBDBAD76, $E0E0DB3B, $32326456,
    $3A3A744E, $A0A141E, $494992DB, $6060C0A, $2424486C, $5C5CB8E4,
    $C2C29F5D, $D3D3BD6E, $ACAC43EF, $6262C4A6, $919139A8, $959531A4,
    $E4E4D337, $7979F28B, $E7E7D532, $C8C88B43, $37376E59, $6D6DDAB7,
    $8D8D018C, $D5D5B164, $4E4E9CD2, $A9A949E0, $6C6CD8B4, $5656ACFA,
    $F4F4F307, $EAEACF25, $6565CAAF, $7A7AF48E, $AEAE47E9, $8081018,
    $BABA6FD5, $7878F088, $25254A6F, $2E2E5C72, $1C1C3824, $A6A657F1,
    $B4B473C7, $C6C69751, $E8E8CB23, $DDDDA17C, $7474E89C, $1F1F3E21,
    $4B4B96DD, $BDBD61DC, $8B8B0D86, $8A8A0F85, $7070E090, $3E3E7C42,
    $B5B571C4, $6666CCAA, $484890D8, $3030605, $F6F6F701, $E0E1C12,
    $6161C2A3, $35356A5F, $5757AEF9, $B9B969D0, $86861791, $C1C19958,
    $1D1D3A27, $9E9E27B9, $E1E1D938, $F8F8EB13, $98982BB3, $11112233,
    $6969D2BB, $D9D9A970, $8E8E0789, $949433A7, $9B9B2DB6, $1E1E3C22,
    $87871592, $E9E9C920, $CECE8749, $5555AAFF, $28285078, $DFDFA57A,
    $8C8C038F, $A1A159F8, $89890980, $D0D1A17, $BFBF65DA, $E6E6D731,
    $424284C6, $6868D0B8, $414182C3, $999929B0, $2D2D5A77, $F0F1E11,
    $B0B07BCB, $5454A8FC, $BBBB6DD6, $16162C3A
     ) ;
  FInv1: array[0..255] of longword =
     ( 
    $A7F45150, $65417E53, $A4171AC3, $5E273A96, $6BAB3BCB, $459D1FF1,
    $58FAACAB, $3E34B93, $FA302055, $6D76ADF6, $76CC8891, $4C02F525,
    $D7E54FFC, $CB2AC5D7, $44352680, $A362B58F, $5AB1DE49, $1BBA2567,
    $EEA4598, $C0FE5DE1, $752FC302, $F04C8112, $97468DA3, $F9D36BC6,
    $5F8F03E7, $9C921595, $7A6DBFEB, $595295DA, $83BED42D, $217458D3,
    $69E04929, $C8C98E44, $89C2756A, $798EF478, $3E58996B, $71B927DD,
    $4FE1BEB6, $AD88F017, $AC20C966, $3ACE7DB4, $4ADF6318, $311AE582,
    $33519760, $7F536245, $7764B1E0, $AE6BBB84, $A081FE1C, $2B08F994,
    $68487058, $FD458F19, $6CDE9487, $F87B52B7, $D373AB23, $24B72E2,
    $8F1FE357, $AB55662A, $28EBB207, $C2B52F03, $7BC5869A, $837D3A5,
    $872830F2, $A5BF23B2, $6A0302BA, $8216ED5C, $1CCF8A2B, $B479A792,
    $F207F3F0, $E2694EA1, $F4DA65CD, $BE0506D5, $6234D11F, $FEA6C48A,
    $532E349D, $55F3A2A0, $E18A0532, $EBF6A475, $EC830B39, $EF6040AA,
    $9F715E06, $106EBD51, $8A213EF9, $6DD963D, $53EDDAE, $BDE64D46,
    $8D5491B5, $5DC47105, $D406046F, $155060FF, $FB981924, $E9BDD697,
    $434089CC, $9ED96777, $42E8B0BD, $8B890788, $5B19E738, $EEC879DB,
    $A7CA147, $F427CE9, $1E84F8C9, $0, $86800983, $ED2B3248,
    $70111EAC, $725A6C4E, $FF0EFDFB, $38850F56, $D5AE3D1E, $392D3627,
    $D90F0A64, $A65C6821, $545B9BD1, $2E36243A, $670A0CB1, $E757930F,
    $96EEB4D2, $919B1B9E, $C5C0804F, $20DC61A2, $4B775A69, $1A121C16,
    $BA93E20A, $2AA0C0E5, $E0223C43, $171B121D, $D090E0B, $C78BF2AD,
    $A8B62DB9, $A91E14C8, $19F15785, $775AF4C, $DD99EEBB, $607FA3FD,
    $2601F79F, $F5725CBC, $3B6644C5, $7EFB5B34, $29438B76, $C623CBDC,
    $FCEDB668, $F1E4B863, $DC31D7CA, $85634210, $22971340, $11C68420,
    $244A857D, $3DBBD2F8, $32F9AE11, $A129C76D, $2F9E1D4B, $30B2DCF3,
    $52860DEC, $E3C177D0, $16B32B6C, $B970A999, $489411FA, $64E94722,
    $8CFCA8C4, $3FF0A01A, $2C7D56D8, $903322EF, $4E4987C7, $D138D9C1,
    $A2CA8CFE, $BD49836, $81F5A6CF, $DE7AA528, $8EB7DA26, $BFAD3FA4,
    $9D3A2CE4, $9278500D, $CC5F6A9B, $467E5462, $138DF6C2, $B8D890E8,
    $F7392E5E, $AFC382F5, $805D9FBE, $93D0697C, $2DD56FA9, $1225CFB3,
    $99ACC83B, $7D1810A7, $639CE86E, $BB3BDB7B, $7826CD09, $18596EF4,
    $B79AEC01, $9A4F83A8, $6E95E665, $E6FFAA7E, $CFBC2108, $E815EFE6,
    $9BE7BAD9, $366F4ACE, $99FEAD4, $7CB029D6, $B2A431AF, $233F2A31,
    $94A5C630, $66A235C0, $BC4E7437, $CA82FCA6, $D090E0B0, $D8A73315,
    $9804F14A, $DAEC41F7, $50CD7F0E, $F691172F, $D64D768D, $B0EF434D,
    $4DAACC54, $496E4DF, $B5D19EE3, $886A4C1B, $1F2CC1B8, $5165467F,
    $EA5E9D04, $358C015D, $7487FA73, $410BFB2E, $1D67B35A, $D2DB9252,
    $5610E933, $47D66D13, $61D79A8C, $CA1377A, $14F8598E, $3C13EB89,
    $27A9CEEE, $C961B735, $E51CE1ED, $B1477A3C, $DFD29C59, $73F2553F,
    $CE141879, $37C773BF, $CDF753EA, $AAFD5F5B, $6F3DDF14, $DB447886,
    $F3AFCA81, $C468B93E, $3424382C, $40A3C25F, $C31D1672, $25E2BC0C,
    $493C288B, $950DFF41, $1A83971, $B30C08DE, $E4B4D89C, $C1566490,
    $84CB7B61, $B632D570, $5C6C4874, $57B8D042
     ) ;
  F2: array[0..255] of longword =
     ( 
    $63C6A563, $7CF8847C, $77EE9977, $7BF68D7B, $F2FF0DF2, $6BD6BD6B,
    $6FDEB16F, $C59154C5, $30605030, $1020301, $67CEA967, $2B567D2B,
    $FEE719FE, $D7B562D7, $AB4DE6AB, $76EC9A76, $CA8F45CA, $821F9D82,
    $C98940C9, $7DFA877D, $FAEF15FA, $59B2EB59, $478EC947, $F0FB0BF0,
    $AD41ECAD, $D4B367D4, $A25FFDA2, $AF45EAAF, $9C23BF9C, $A453F7A4,
    $72E49672, $C09B5BC0, $B775C2B7, $FDE11CFD, $933DAE93, $264C6A26,
    $366C5A36, $3F7E413F, $F7F502F7, $CC834FCC, $34685C34, $A551F4A5,
    $E5D134E5, $F1F908F1, $71E29371, $D8AB73D8, $31625331, $152A3F15,
    $4080C04, $C79552C7, $23466523, $C39D5EC3, $18302818, $9637A196, 
    $50A0F05, $9A2FB59A, $70E0907, $12243612, $801B9B80, $E2DF3DE2, 
    $EBCD26EB, $274E6927, $B27FCDB2, $75EA9F75, $9121B09, $831D9E83, 
    $2C58742C, $1A342E1A, $1B362D1B, $6EDCB26E, $5AB4EE5A, $A05BFBA0, 
    $52A4F652, $3B764D3B, $D6B761D6, $B37DCEB3, $29527B29, $E3DD3EE3, 
    $2F5E712F, $84139784, $53A6F553, $D1B968D1, $0, $EDC12CED, 
    $20406020, $FCE31FFC, $B179C8B1, $5BB6ED5B, $6AD4BE6A, $CB8D46CB, 
    $BE67D9BE, $39724B39, $4A94DE4A, $4C98D44C, $58B0E858, $CF854ACF, 
    $D0BB6BD0, $EFC52AEF, $AA4FE5AA, $FBED16FB, $4386C543, $4D9AD74D, 
    $33665533, $85119485, $458ACF45, $F9E910F9, $2040602, $7FFE817F, 
    $50A0F050, $3C78443C, $9F25BA9F, $A84BE3A8, $51A2F351, $A35DFEA3, 
    $4080C040, $8F058A8F, $923FAD92, $9D21BC9D, $38704838, $F5F104F5, 
    $BC63DFBC, $B677C1B6, $DAAF75DA, $21426321, $10203010, $FFE51AFF, 
    $F3FD0EF3, $D2BF6DD2, $CD814CCD, $C18140C, $13263513, $ECC32FEC, 
    $5FBEE15F, $9735A297, $4488CC44, $172E3917, $C49357C4, $A755F2A7, 
    $7EFC827E, $3D7A473D, $64C8AC64, $5DBAE75D, $19322B19, $73E69573, 
    $60C0A060, $81199881, $4F9ED14F, $DCA37FDC, $22446622, $2A547E2A, 
    $903BAB90, $880B8388, $468CCA46, $EEC729EE, $B86BD3B8, $14283C14, 
    $DEA779DE, $5EBCE25E, $B161D0B, $DBAD76DB, $E0DB3BE0, $32645632, 
    $3A744E3A, $A141E0A, $4992DB49, $60C0A06, $24486C24, $5CB8E45C,
    $C29F5DC2, $D3BD6ED3, $AC43EFAC, $62C4A662, $9139A891, $9531A495, 
    $E4D337E4, $79F28B79, $E7D532E7, $C88B43C8, $376E5937, $6DDAB76D, 
    $8D018C8D, $D5B164D5, $4E9CD24E, $A949E0A9, $6CD8B46C, $56ACFA56, 
    $F4F307F4, $EACF25EA, $65CAAF65, $7AF48E7A, $AE47E9AE, $8101808, 
    $BA6FD5BA, $78F08878, $254A6F25, $2E5C722E, $1C38241C, $A657F1A6, 
    $B473C7B4, $C69751C6, $E8CB23E8, $DDA17CDD, $74E89C74, $1F3E211F, 
    $4B96DD4B, $BD61DCBD, $8B0D868B, $8A0F858A, $70E09070, $3E7C423E, 
    $B571C4B5, $66CCAA66, $4890D848, $3060503, $F6F701F6, $E1C120E, 
    $61C2A361, $356A5F35, $57AEF957, $B969D0B9, $86179186, $C19958C1, 
    $1D3A271D, $9E27B99E, $E1D938E1, $F8EB13F8, $982BB398, $11223311, 
    $69D2BB69, $D9A970D9, $8E07898E, $9433A794, $9B2DB69B, $1E3C221E, 
    $87159287, $E9C920E9, $CE8749CE, $55AAFF55, $28507828, $DFA57ADF, 
    $8C038F8C, $A159F8A1, $89098089, $D1A170D, $BF65DABF, $E6D731E6, 
    $4284C642, $68D0B868, $4182C341, $9929B099, $2D5A772D, $F1E110F, 
    $B07BCBB0, $54A8FC54, $BB6DD6BB, $162C3A16
     ) ;
  FInv2: array[0..255] of longword =
     ( 
    $F45150A7, $417E5365, $171AC3A4, $273A965E, $AB3BCB6B, $9D1FF145,
    $FAACAB58, $E34B9303, $302055FA, $76ADF66D, $CC889176, $2F5254C, 
    $E54FFCD7, $2AC5D7CB, $35268044, $62B58FA3, $B1DE495A, $BA25671B, 
    $EA45980E, $FE5DE1C0, $2FC30275, $4C8112F0, $468DA397, $D36BC6F9, 
    $8F03E75F, $9215959C, $6DBFEB7A, $5295DA59, $BED42D83, $7458D321, 
    $E0492969, $C98E44C8, $C2756A89, $8EF47879, $58996B3E, $B927DD71, 
    $E1BEB64F, $88F017AD, $20C966AC, $CE7DB43A, $DF63184A, $1AE58231, 
    $51976033, $5362457F, $64B1E077, $6BBB84AE, $81FE1CA0, $8F9942B, 
    $48705868, $458F19FD, $DE94876C, $7B52B7F8, $73AB23D3, $4B72E202,
    $1FE3578F, $55662AAB, $EBB20728, $B52F03C2, $C5869A7B, $37D3A508, 
    $2830F287, $BF23B2A5, $302BA6A, $16ED5C82, $CF8A2B1C, $79A792B4, 
    $7F3F0F2, $694EA1E2, $DA65CDF4, $506D5BE, $34D11F62, $A6C48AFE, 
    $2E349D53, $F3A2A055, $8A0532E1, $F6A475EB, $830B39EC, $6040AAEF, 
    $715E069F, $6EBD5110, $213EF98A, $DD963D06, $3EDDAE05, $E64D46BD, 
    $5491B58D, $C471055D, $6046FD4, $5060FF15, $981924FB, $BDD697E9, 
    $4089CC43, $D967779E, $E8B0BD42, $8907888B, $19E7385B, $C879DBEE, 
    $7CA1470A, $427CE90F, $84F8C91E, $0, $80098386, $2B3248ED, 
    $111EAC70, $5A6C4E72, $EFDFBFF, $850F5638, $AE3D1ED5, $2D362739, 
    $F0A64D9, $5C6821A6, $5B9BD154, $36243A2E, $A0CB167, $57930FE7, 
    $EEB4D296, $9B1B9E91, $C0804FC5, $DC61A220, $775A694B, $121C161A, 
    $93E20ABA, $A0C0E52A, $223C43E0, $1B121D17, $90E0B0D, $8BF2ADC7, 
    $B62DB9A8, $1E14C8A9, $F1578519, $75AF4C07, $99EEBBDD, $7FA3FD60, 
    $1F79F26, $725CBCF5, $6644C53B, $FB5B347E, $438B7629, $23CBDCC6, 
    $EDB668FC, $E4B863F1, $31D7CADC, $63421085, $97134022, $C6842011, 
    $4A857D24, $BBD2F83D, $F9AE1132, $29C76DA1, $9E1D4B2F, $B2DCF330, 
    $860DEC52, $C177D0E3, $B32B6C16, $70A999B9, $9411FA48, $E9472264, 
    $FCA8C48C, $F0A01A3F, $7D56D82C, $3322EF90, $4987C74E, $38D9C1D1, 
    $CA8CFEA2, $D498360B, $F5A6CF81, $7AA528DE, $B7DA268E, $AD3FA4BF, 
    $3A2CE49D, $78500D92, $5F6A9BCC, $7E546246, $8DF6C213, $D890E8B8, 
    $392E5EF7, $C382F5AF, $5D9FBE80, $D0697C93, $D56FA92D, $25CFB312, 
    $ACC83B99, $1810A77D, $9CE86E63, $3BDB7BBB, $26CD0978, $596EF418, 
    $9AEC01B7, $4F83A89A, $95E6656E, $FFAA7EE6, $BC2108CF, $15EFE6E8, 
    $E7BAD99B, $6F4ACE36, $9FEAD409, $B029D67C, $A431AFB2, $3F2A3123, 
    $A5C63094, $A235C066, $4E7437BC, $82FCA6CA, $90E0B0D0, $A73315D8, 
    $4F14A98, $EC41F7DA, $CD7F0E50, $91172FF6, $4D768DD6, $EF434DB0, 
    $AACC544D, $96E4DF04, $D19EE3B5, $6A4C1B88, $2CC1B81F, $65467F51,
    $5E9D04EA, $8C015D35, $87FA7374, $BFB2E41, $67B35A1D, $DB9252D2, 
    $10E93356, $D66D1347, $D79A8C61, $A1377A0C, $F8598E14, $13EB893C, 
    $A9CEEE27, $61B735C9, $1CE1EDE5, $477A3CB1, $D29C59DF, $F2553F73, 
    $141879CE, $C773BF37, $F753EACD, $FD5F5BAA, $3DDF146F, $447886DB, 
    $AFCA81F3, $68B93EC4, $24382C34, $A3C25F40, $1D1672C3, $E2BC0C25, 
    $3C288B49, $DFF4195, $A8397101, $C08DEB3, $B4D89CE4, $566490C1, 
    $CB7B6184, $32D570B6, $6C48745C, $B8D04257
     ) ;
  F3: array[0..255] of longword =
     ( 
    $C6A56363, $F8847C7C, $EE997777, $F68D7B7B, $FF0DF2F2, $D6BD6B6B,
    $DEB16F6F, $9154C5C5, $60503030, $2030101, $CEA96767, $567D2B2B,
    $E719FEFE, $B562D7D7, $4DE6ABAB, $EC9A7676, $8F45CACA, $1F9D8282,
    $8940C9C9, $FA877D7D, $EF15FAFA, $B2EB5959, $8EC94747, $FB0BF0F0,
    $41ECADAD, $B367D4D4, $5FFDA2A2, $45EAAFAF, $23BF9C9C, $53F7A4A4,
    $E4967272, $9B5BC0C0, $75C2B7B7, $E11CFDFD, $3DAE9393, $4C6A2626,
    $6C5A3636, $7E413F3F, $F502F7F7, $834FCCCC, $685C3434, $51F4A5A5,
    $D134E5E5, $F908F1F1, $E2937171, $AB73D8D8, $62533131, $2A3F1515,
    $80C0404, $9552C7C7, $46652323, $9D5EC3C3, $30281818, $37A19696,
    $A0F0505, $2FB59A9A, $E090707, $24361212, $1B9B8080, $DF3DE2E2,
    $CD26EBEB, $4E692727, $7FCDB2B2, $EA9F7575, $121B0909, $1D9E8383,
    $58742C2C, $342E1A1A, $362D1B1B, $DCB26E6E, $B4EE5A5A, $5BFBA0A0,
    $A4F65252, $764D3B3B, $B761D6D6, $7DCEB3B3, $527B2929, $DD3EE3E3,
    $5E712F2F, $13978484, $A6F55353, $B968D1D1, $0, $C12CEDED,
    $40602020, $E31FFCFC, $79C8B1B1, $B6ED5B5B, $D4BE6A6A, $8D46CBCB,
    $67D9BEBE, $724B3939, $94DE4A4A, $98D44C4C, $B0E85858, $854ACFCF,
    $BB6BD0D0, $C52AEFEF, $4FE5AAAA, $ED16FBFB, $86C54343, $9AD74D4D,
    $66553333, $11948585, $8ACF4545, $E910F9F9, $4060202, $FE817F7F,
    $A0F05050, $78443C3C, $25BA9F9F, $4BE3A8A8, $A2F35151, $5DFEA3A3,
    $80C04040, $58A8F8F, $3FAD9292, $21BC9D9D, $70483838, $F104F5F5,
    $63DFBCBC, $77C1B6B6, $AF75DADA, $42632121, $20301010, $E51AFFFF,
    $FD0EF3F3, $BF6DD2D2, $814CCDCD, $18140C0C, $26351313, $C32FECEC,
    $BEE15F5F, $35A29797, $88CC4444, $2E391717, $9357C4C4, $55F2A7A7,
    $FC827E7E, $7A473D3D, $C8AC6464, $BAE75D5D, $322B1919, $E6957373,
    $C0A06060, $19988181, $9ED14F4F, $A37FDCDC, $44662222, $547E2A2A,
    $3BAB9090, $B838888, $8CCA4646, $C729EEEE, $6BD3B8B8, $283C1414,
    $A779DEDE, $BCE25E5E, $161D0B0B, $AD76DBDB, $DB3BE0E0, $64563232,
    $744E3A3A, $141E0A0A, $92DB4949, $C0A0606, $486C2424, $B8E45C5C,
    $9F5DC2C2, $BD6ED3D3, $43EFACAC, $C4A66262, $39A89191, $31A49595,
    $D337E4E4, $F28B7979, $D532E7E7, $8B43C8C8, $6E593737, $DAB76D6D,
    $18C8D8D, $B164D5D5, $9CD24E4E, $49E0A9A9, $D8B46C6C, $ACFA5656,
    $F307F4F4, $CF25EAEA, $CAAF6565, $F48E7A7A, $47E9AEAE, $10180808,
    $6FD5BABA, $F0887878, $4A6F2525, $5C722E2E, $38241C1C, $57F1A6A6,
    $73C7B4B4, $9751C6C6, $CB23E8E8, $A17CDDDD, $E89C7474, $3E211F1F,
    $96DD4B4B, $61DCBDBD, $D868B8B, $F858A8A, $E0907070, $7C423E3E,
    $71C4B5B5, $CCAA6666, $90D84848, $6050303, $F701F6F6, $1C120E0E,
    $C2A36161, $6A5F3535, $AEF95757, $69D0B9B9, $17918686, $9958C1C1,
    $3A271D1D, $27B99E9E, $D938E1E1, $EB13F8F8, $2BB39898, $22331111,
    $D2BB6969, $A970D9D9, $7898E8E, $33A79494, $2DB69B9B, $3C221E1E,
    $15928787, $C920E9E9, $8749CECE, $AAFF5555, $50782828, $A57ADFDF,
    $38F8C8C, $59F8A1A1, $9808989, $1A170D0D, $65DABFBF, $D731E6E6,
    $84C64242, $D0B86868, $82C34141, $29B09999, $5A772D2D, $1E110F0F,
    $7BCBB0B0, $A8FC5454, $6DD6BBBB, $2C3A1616
     ) ;
  FInv3: array[0..255] of longword =
     ( 
    $5150A7F4, $7E536541, $1AC3A417, $3A965E27, $3BCB6BAB, $1FF1459D,
    $ACAB58FA, $4B9303E3, $2055FA30, $ADF66D76, $889176CC, $F5254C02,
    $4FFCD7E5, $C5D7CB2A, $26804435, $B58FA362, $DE495AB1, $25671BBA,
    $45980EEA, $5DE1C0FE, $C302752F, $8112F04C, $8DA39746, $6BC6F9D3,
    $3E75F8F, $15959C92, $BFEB7A6D, $95DA5952, $D42D83BE, $58D32174,
    $492969E0, $8E44C8C9, $756A89C2, $F478798E, $996B3E58, $27DD71B9,
    $BEB64FE1, $F017AD88, $C966AC20, $7DB43ACE, $63184ADF, $E582311A,
    $97603351, $62457F53, $B1E07764, $BB84AE6B, $FE1CA081, $F9942B08,
    $70586848, $8F19FD45, $94876CDE, $52B7F87B, $AB23D373, $72E2024B,
    $E3578F1F, $662AAB55, $B20728EB, $2F03C2B5, $869A7BC5, $D3A50837,
    $30F28728, $23B2A5BF, $2BA6A03, $ED5C8216, $8A2B1CCF, $A792B479, 
    $F3F0F207, $4EA1E269, $65CDF4DA, $6D5BE05, $D11F6234, $C48AFEA6, 
    $349D532E, $A2A055F3, $532E18A, $A475EBF6, $B39EC83, $40AAEF60, 
    $5E069F71, $BD51106E, $3EF98A21, $963D06DD, $DDAE053E, $4D46BDE6, 
    $91B58D54, $71055DC4, $46FD406, $60FF1550, $1924FB98, $D697E9BD, 
    $89CC4340, $67779ED9, $B0BD42E8, $7888B89, $E7385B19, $79DBEEC8, 
    $A1470A7C, $7CE90F42, $F8C91E84, $0, $9838680, $3248ED2B, 
    $1EAC7011, $6C4E725A, $FDFBFF0E, $F563885, $3D1ED5AE, $3627392D, 
    $A64D90F, $6821A65C, $9BD1545B, $243A2E36, $CB1670A, $930FE757, 
    $B4D296EE, $1B9E919B, $804FC5C0, $61A220DC, $5A694B77, $1C161A12, 
    $E20ABA93, $C0E52AA0, $3C43E022, $121D171B, $E0B0D09, $F2ADC78B, 
    $2DB9A8B6, $14C8A91E, $578519F1, $AF4C0775, $EEBBDD99, $A3FD607F, 
    $F79F2601, $5CBCF572, $44C53B66, $5B347EFB, $8B762943, $CBDCC623, 
    $B668FCED, $B863F1E4, $D7CADC31, $42108563, $13402297, $842011C6, 
    $857D244A, $D2F83DBB, $AE1132F9, $C76DA129, $1D4B2F9E, $DCF330B2,
    $DEC5286, $77D0E3C1, $2B6C16B3, $A999B970, $11FA4894, $472264E9, 
    $A8C48CFC, $A01A3FF0, $56D82C7D, $22EF9033, $87C74E49, $D9C1D138, 
    $8CFEA2CA, $98360BD4, $A6CF81F5, $A528DE7A, $DA268EB7, $3FA4BFAD, 
    $2CE49D3A, $500D9278, $6A9BCC5F, $5462467E, $F6C2138D, $90E8B8D8, 
    $2E5EF739, $82F5AFC3, $9FBE805D, $697C93D0, $6FA92DD5, $CFB31225, 
    $C83B99AC, $10A77D18, $E86E639C, $DB7BBB3B, $CD097826, $6EF41859, 
    $EC01B79A, $83A89A4F, $E6656E95, $AA7EE6FF, $2108CFBC, $EFE6E815, 
    $BAD99BE7, $4ACE366F, $EAD4099F, $29D67CB0, $31AFB2A4, $2A31233F, 
    $C63094A5, $35C066A2, $7437BC4E, $FCA6CA82, $E0B0D090, $3315D8A7, 
    $F14A9804, $41F7DAEC, $7F0E50CD, $172FF691, $768DD64D, $434DB0EF, 
    $CC544DAA, $E4DF0496, $9EE3B5D1, $4C1B886A, $C1B81F2C, $467F5165, 
    $9D04EA5E, $15D358C, $FA737487, $FB2E410B, $B35A1D67, $9252D2DB, 
    $E9335610, $6D1347D6, $9A8C61D7, $377A0CA1, $598E14F8, $EB893C13, 
    $CEEE27A9, $B735C961, $E1EDE51C, $7A3CB147, $9C59DFD2, $553F73F2, 
    $1879CE14, $73BF37C7, $53EACDF7, $5F5BAAFD, $DF146F3D, $7886DB44, 
    $CA81F3AF, $B93EC468, $382C3424, $C25F40A3, $1672C31D, $BC0C25E2, 
    $288B493C, $FF41950D, $397101A8, $8DEB30C, $D89CE4B4, $6490C156, 
    $7B6184CB, $D570B632, $48745C6C, $D04257B8
     ) ;

  LF: array[0..255] of longword = 
   ( 
    $00000063, $0000007C, $00000077, $0000007B, $000000F2, $0000006B,
    $0000006F, $000000C5, $00000030, $00000001, $00000067, $0000002B,
    $000000FE, $000000D7, $000000AB, $00000076, $000000CA, $00000082,
    $000000C9, $0000007D, $000000FA, $00000059, $00000047, $000000F0,
    $000000AD, $000000D4, $000000A2, $000000AF, $0000009C, $000000A4,
    $00000072, $000000C0, $000000B7, $000000FD, $00000093, $00000026,
    $00000036, $0000003F, $000000F7, $000000CC, $00000034, $000000A5,
    $000000E5, $000000F1, $00000071, $000000D8, $00000031, $00000015,
    $00000004, $000000C7, $00000023, $000000C3, $00000018, $00000096,
    $00000005, $0000009A, $00000007, $00000012, $00000080, $000000E2,
    $000000EB, $00000027, $000000B2, $00000075, $00000009, $00000083,
    $0000002C, $0000001A, $0000001B, $0000006E, $0000005A, $000000A0,
    $00000052, $0000003B, $000000D6, $000000B3, $00000029, $000000E3,
    $0000002F, $00000084, $00000053, $000000D1, $00000000, $000000ED,
    $00000020, $000000FC, $000000B1, $0000005B, $0000006A, $000000CB,
    $000000BE, $00000039, $0000004A, $0000004C, $00000058, $000000CF,
    $000000D0, $000000EF, $000000AA, $000000FB, $00000043, $0000004D,
    $00000033, $00000085, $00000045, $000000F9, $00000002, $0000007F,
    $00000050, $0000003C, $0000009F, $000000A8, $00000051, $000000A3,
    $00000040, $0000008F, $00000092, $0000009D, $00000038, $000000F5,
    $000000BC, $000000B6, $000000DA, $00000021, $00000010, $000000FF,
    $000000F3, $000000D2, $000000CD, $0000000C, $00000013, $000000EC,
    $0000005F, $00000097, $00000044, $00000017, $000000C4, $000000A7,
    $0000007E, $0000003D, $00000064, $0000005D, $00000019, $00000073,
    $00000060, $00000081, $0000004F, $000000DC, $00000022, $0000002A,
    $00000090, $00000088, $00000046, $000000EE, $000000B8, $00000014,
    $000000DE, $0000005E, $0000000B, $000000DB, $000000E0, $00000032,
    $0000003A, $0000000A, $00000049, $00000006, $00000024, $0000005C,
    $000000C2, $000000D3, $000000AC, $00000062, $00000091, $00000095,
    $000000E4, $00000079, $000000E7, $000000C8, $00000037, $0000006D,
    $0000008D, $000000D5, $0000004E, $000000A9, $0000006C, $00000056,
    $000000F4, $000000EA, $00000065, $0000007A, $000000AE, $00000008,
    $000000BA, $00000078, $00000025, $0000002E, $0000001C, $000000A6,
    $000000B4, $000000C6, $000000E8, $000000DD, $00000074, $0000001F,
    $0000004B, $000000BD, $0000008B, $0000008A, $00000070, $0000003E,
    $000000B5, $00000066, $00000048, $00000003, $000000F6, $0000000E,
    $00000061, $00000035, $00000057, $000000B9, $00000086, $000000C1,
    $0000001D, $0000009E, $000000E1, $000000F8, $00000098, $00000011,
    $00000069, $000000D9, $0000008E, $00000094, $0000009B, $0000001E,
    $00000087, $000000E9, $000000CE, $00000055, $00000028, $000000DF,
    $0000008C, $000000A1, $00000089, $0000000D, $000000BF, $000000E6,
    $00000042, $00000068, $00000041, $00000099, $0000002D, $0000000F,
    $000000B0, $00000054, $000000BB, $00000016
     ) ;
  LFInv: array[0..255] of longword = 
     ( 
    $00000052, $00000009, $0000006A, $000000D5, $00000030, $00000036,
    $000000A5, $00000038, $000000BF, $00000040, $000000A3, $0000009E,
    $00000081, $000000F3, $000000D7, $000000FB, $0000007C, $000000E3,
    $00000039, $00000082, $0000009B, $0000002F, $000000FF, $00000087,
    $00000034, $0000008E, $00000043, $00000044, $000000C4, $000000DE,
    $000000E9, $000000CB, $00000054, $0000007B, $00000094, $00000032,
    $000000A6, $000000C2, $00000023, $0000003D, $000000EE, $0000004C,
    $00000095, $0000000B, $00000042, $000000FA, $000000C3, $0000004E,
    $00000008, $0000002E, $000000A1, $00000066, $00000028, $000000D9,
    $00000024, $000000B2, $00000076, $0000005B, $000000A2, $00000049,
    $0000006D, $0000008B, $000000D1, $00000025, $00000072, $000000F8,
    $000000F6, $00000064, $00000086, $00000068, $00000098, $00000016,
    $000000D4, $000000A4, $0000005C, $000000CC, $0000005D, $00000065,
    $000000B6, $00000092, $0000006C, $00000070, $00000048, $00000050,
    $000000FD, $000000ED, $000000B9, $000000DA, $0000005E, $00000015,
    $00000046, $00000057, $000000A7, $0000008D, $0000009D, $00000084,
    $00000090, $000000D8, $000000AB, $00000000, $0000008C, $000000BC,
    $000000D3, $0000000A, $000000F7, $000000E4, $00000058, $00000005,
    $000000B8, $000000B3, $00000045, $00000006, $000000D0, $0000002C,
    $0000001E, $0000008F, $000000CA, $0000003F, $0000000F, $00000002,
    $000000C1, $000000AF, $000000BD, $00000003, $00000001, $00000013,
    $0000008A, $0000006B, $0000003A, $00000091, $00000011, $00000041,
    $0000004F, $00000067, $000000DC, $000000EA, $00000097, $000000F2,
    $000000CF, $000000CE, $000000F0, $000000B4, $000000E6, $00000073,
    $00000096, $000000AC, $00000074, $00000022, $000000E7, $000000AD,
    $00000035, $00000085, $000000E2, $000000F9, $00000037, $000000E8,
    $0000001C, $00000075, $000000DF, $0000006E, $00000047, $000000F1,
    $0000001A, $00000071, $0000001D, $00000029, $000000C5, $00000089,
    $0000006F, $000000B7, $00000062, $0000000E, $000000AA, $00000018,
    $000000BE, $0000001B, $000000FC, $00000056, $0000003E, $0000004B,
    $000000C6, $000000D2, $00000079, $00000020, $0000009A, $000000DB,
    $000000C0, $000000FE, $00000078, $000000CD, $0000005A, $000000F4,
    $0000001F, $000000DD, $000000A8, $00000033, $00000088, $00000007,
    $000000C7, $00000031, $000000B1, $00000012, $00000010, $00000059,
    $00000027, $00000080, $000000EC, $0000005F, $00000060, $00000051,
    $0000007F, $000000A9, $00000019, $000000B5, $0000004A, $0000000D,
    $0000002D, $000000E5, $0000007A, $0000009F, $00000093, $000000C9,
    $0000009C, $000000EF, $000000A0, $000000E0, $0000003B, $0000004D,
    $000000AE, $0000002A, $000000F5, $000000B0, $000000C8, $000000EB,
    $000000BB, $0000003C, $00000083, $00000053, $00000099, $00000061,
    $00000017, $0000002B, $00000004, $0000007E, $000000BA, $00000077,
    $000000D6, $00000026, $000000E1, $00000069, $00000014, $00000063,
    $00000055, $00000021, $0000000C, $0000007D
     ) ;

// Key expansion routines

procedure ExpandKeyForEncryption128(const Key:   TAESKey128  ;
  out ExpandedKey: TAESExpandedKey128);
var
  I, J: integer;
  T: longword;
  W0, W1, W2, W3: longword;
begin

  ExpandedKey[0] := PLongWord(@Key[0])^;
  ExpandedKey[1] := PLongWord(@Key[4])^;
  ExpandedKey[2] := PLongWord(@Key[8])^;
  ExpandedKey[3] := PLongWord(@Key[12])^;
  I := 0;
  J := 1;
  repeat
    T := (ExpandedKey[I + 3] shl 24) or (ExpandedKey[I + 3] shr 8);
    W0 := LastForwardTable[Byte(T)];
    W1 := LastForwardTable[Byte(T shr 8)];
    W2 := LastForwardTable[Byte(T shr 16)];
    W3 := LastForwardTable[Byte(T shr 24)];
    ExpandedKey[I + 4] := ExpandedKey[I] xor (W0 xor ((W1 shl 8) or (W1 shr 24)) xor
      ((W2 shl 16) or (W2 shr 16)) xor ((W3 shl 24) or (W3 shr 8))) xor Rcon[J];
    Inc(J);
    ExpandedKey[I + 5] := ExpandedKey[I + 1] xor ExpandedKey[I + 4];
    ExpandedKey[I + 6] := ExpandedKey[I + 2] xor ExpandedKey[I + 5];
    ExpandedKey[I + 7] := ExpandedKey[I + 3] xor ExpandedKey[I + 6];
    Inc(I, 4);
  until I >= 40;
end;

procedure ExpandKeyForEncryption192(const Key:   TAESKey192  ;
  out ExpandedKey: TAESExpandedKey192);
var
  I, J: integer;
  T: longword;
  W0, W1, W2, W3: longword;
begin

  ExpandedKey[0] := PLongWord(@Key[0])^;
  ExpandedKey[1] := PLongWord(@Key[4])^;
  ExpandedKey[2] := PLongWord(@Key[8])^;
  ExpandedKey[3] := PLongWord(@Key[12])^;
  ExpandedKey[4] := PLongWord(@Key[16])^;
  ExpandedKey[5] := PLongWord(@Key[20])^;
  I := 0;
  J := 1;
  repeat
    T := (ExpandedKey[I + 5] shl 24) or (ExpandedKey[I + 5] shr 8);
    W0 := LastForwardTable[Byte(T)];
    W1 := LastForwardTable[Byte(T shr 8)];
    W2 := LastForwardTable[Byte(T shr 16)];
    W3 := LastForwardTable[Byte(T shr 24)];
    ExpandedKey[I + 6] := ExpandedKey[I] xor (W0 xor ((W1 shl 8) or (W1 shr 24))
      xor ((W2 shl 16) or (W2 shr 16)) xor ((W3 shl 24) or (W3 shr 8))) xor Rcon[J];
    Inc(J);
    ExpandedKey[I + 7] := ExpandedKey[I + 1] xor ExpandedKey[I + 6];
    ExpandedKey[I + 8] := ExpandedKey[I + 2] xor ExpandedKey[I + 7];
    ExpandedKey[I + 9] := ExpandedKey[I + 3] xor ExpandedKey[I + 8];
    ExpandedKey[I + 10] := ExpandedKey[I + 4] xor ExpandedKey[I + 9];
    ExpandedKey[I + 11] := ExpandedKey[I + 5] xor ExpandedKey[I + 10];
    Inc(I, 6);
  until I >= 46;
end;

procedure ExpandKeyForEncryption256(const Key:   TAESKey256  ;
  out ExpandedKey: TAESExpandedKey256);
var
  I, J: integer;
  T: longword;
  W0, W1, W2, W3: longword;
begin

  ExpandedKey[0] := PLongWord(@Key[0])^;
  ExpandedKey[1] := PLongWord(@Key[4])^;
  ExpandedKey[2] := PLongWord(@Key[8])^;
  ExpandedKey[3] := PLongWord(@Key[12])^;
  ExpandedKey[4] := PLongWord(@Key[16])^;
  ExpandedKey[5] := PLongWord(@Key[20])^;
  ExpandedKey[6] := PLongWord(@Key[24])^;
  ExpandedKey[7] := PLongWord(@Key[28])^;
  I := 0;
  J := 1;
  repeat
    T := (ExpandedKey[I + 7] shl 24) or (ExpandedKey[I + 7] shr 8);
    W0 := LastForwardTable[Byte(T)];
    W1 := LastForwardTable[Byte(T shr 8)];
    W2 := LastForwardTable[Byte(T shr 16)];
    W3 := LastForwardTable[Byte(T shr 24)];
    ExpandedKey[I + 8] := ExpandedKey[I] xor (W0 xor ((W1 shl 8) or (W1 shr 24))
      xor
      ((W2 shl 16) or (W2 shr 16)) xor ((W3 shl 24) or (W3 shr 8))) xor Rcon[J];
    Inc(J);
    ExpandedKey[I + 9] := ExpandedKey[I + 1] xor ExpandedKey[I + 8];
    ExpandedKey[I + 10] := ExpandedKey[I + 2] xor ExpandedKey[I + 9];
    ExpandedKey[I + 11] := ExpandedKey[I + 3] xor ExpandedKey[I + 10];
    W0 := LastForwardTable[Byte(ExpandedKey[I + 11])];
    W1 := LastForwardTable[Byte(ExpandedKey[I + 11] shr 8)];
    W2 := LastForwardTable[Byte(ExpandedKey[I + 11] shr 16)];
    W3 := LastForwardTable[Byte(ExpandedKey[I + 11] shr 24)];
    ExpandedKey[I + 12] := ExpandedKey[I + 4] xor
      (W0 xor ((W1 shl 8) or (W1 shr 24)) xor
      ((W2 shl 16) or (W2 shr 16)) xor ((W3 shl 24) or (W3 shr 8)));
    ExpandedKey[I + 13] := ExpandedKey[I + 5] xor ExpandedKey[I + 12];
    ExpandedKey[I + 14] := ExpandedKey[I + 6] xor ExpandedKey[I + 13];
    ExpandedKey[I + 15] := ExpandedKey[I + 7] xor ExpandedKey[I + 14];
    Inc(I, 8);
  until I >= 52;
end;

procedure ExpandKeyForDecryption128(var ExpandedKey: TAESExpandedKey128);
var
  I: integer;
  U, F2, F4, F8, F9: longword;
begin

  for I := 1 to 9 do
  begin
    F9 := ExpandedKey[I shl 2];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I shl 2] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I shl 2 + 1];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I shl 2 + 1] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I shl 2 + 2];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I shl 2 + 2] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I shl 2 + 3];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I shl 2 + 3] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
  end;
end;

procedure ExpandKeyForDecryption192(var ExpandedKey: TAESExpandedKey192);
var
  I: integer;
  U, F2, F4, F8, F9: longword;
begin

  for I := 1 to 11 do
  begin
    F9 := ExpandedKey[I shl 2];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I shl 2] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I shl 2 + 1];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I shl 2 + 1] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I  shl 2 + 2];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I  shl 2 + 2] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I  shl 2 + 3];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I  shl 2 + 3] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
  end;
end;

procedure ExpandKeyForDecryption256(var ExpandedKey: TAESExpandedKey256);
var
  I: integer;
  U, F2, F4, F8, F9: longword;
begin

  for I := 1 to 13 do
  begin
    F9 := ExpandedKey[I  shl 2];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I  shl 2] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I  shl 2 + 1];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I  shl 2 + 1] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I  shl 2 + 2];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I  shl 2 + 2] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
    F9 := ExpandedKey[I  shl 2 + 3];
    U := F9 and $80808080;
    F2 := ((F9 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F2 and $80808080;
    F4 := ((F2 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    U := F4 and $80808080;
    F8 := ((F4 and $7F7F7F7F) shl 1) xor ((U - (U shr 7)) and $1B1B1B1B);
    F9 := F9 xor F8;
    ExpandedKey[I  shl 2 + 3] := F2 xor F4 xor F8 xor
      (((F2 xor F9) shl 24) or ((F2 xor F9) shr 8)) xor
      (((F4 xor F9) shl 16) or ((F4 xor F9) shr 16)) xor ((F9 shl 8) or (F9 shr
        24));
  end;
end;

// Block processing routines
// actually the following routines are used only in SBUMAC, so they should be removed later

procedure AesBufferToUInts(const InBuf : TAESBuffer;  var  B0, B1, B2, B3 : cardinal);
begin
  B0 := PLongWord(@InBuf[0])^;
  B1 := PLongWord(@InBuf[4])^;
  B2 := PLongWord(@InBuf[8])^;
  B3 := PLongWord(@InBuf[12])^;
end;

procedure UIntsToAesBuffer(var B0, B1, B2, B3 : cardinal; out OutBuf : TAESBuffer);
begin
  PLongWord(@OutBuf[0])^ := B0;
  PLongWord(@OutBuf[4])^ := B1;
  PLongWord(@OutBuf[8])^ := B2;
  PLongWord(@OutBuf[12])^ := B3;
end;

procedure Encrypt128(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey128; out OutBuf:  TAESBuffer );
var
  B0, B1, B2, B3 : cardinal;
begin
  AesBufferToUInts(InBuf, B0, B1, B2, B3);
  Encrypt128(B0, B1, B2, B3, Key);
  UIntsToAesBuffer(B0, B1, B2, B3, OutBuf);
end;

procedure Encrypt192(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey192; out OutBuf:  TAESBuffer );
var
  B0, B1, B2, B3 : cardinal;
begin
  AesBufferToUInts(InBuf, B0, B1, B2, B3);
  Encrypt192(B0, B1, B2, B3, Key);
  UIntsToAesBuffer(B0, B1, B2, B3, OutBuf);
end;

procedure Encrypt256(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey256; out OutBuf:  TAESBuffer );
var
  B0, B1, B2, B3 : cardinal;
begin
  AesBufferToUInts(InBuf, B0, B1, B2, B3);
  Encrypt256(B0, B1, B2, B3, Key);
  UIntsToAesBuffer(B0, B1, B2, B3, OutBuf);
end;

procedure Decrypt128(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey128; out OutBuf:  TAESBuffer );
var
  B0, B1, B2, B3 : cardinal;
begin
  AesBufferToUInts(InBuf, B0, B1, B2, B3);
  Decrypt128(B0, B1, B2, B3, Key);
  UIntsToAesBuffer(B0, B1, B2, B3, OutBuf);
end;

procedure Decrypt192(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey192; out OutBuf:  TAESBuffer );
var
  B0, B1, B2, B3 : cardinal;
begin
  AesBufferToUInts(InBuf, B0, B1, B2, B3);
  Decrypt192(B0, B1, B2, B3, Key);
  UIntsToAesBuffer(B0, B1, B2, B3, OutBuf);
end;

procedure Decrypt256(const InBuf:  TAESBuffer ; const Key: TAESExpandedKey256; out OutBuf:  TAESBuffer );
var
  B0, B1, B2, B3 : cardinal;
begin
  AesBufferToUInts(InBuf, B0, B1, B2, B3);
  Decrypt256(B0, B1, B2, B3, Key);
  UIntsToAesBuffer(B0, B1, B2, B3, OutBuf);
end;


procedure Encrypt128(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey128);
var
  T00, T01, T02, T03, T10, T11, T12, T13 : LongWord;
begin
  // initializing
  T00 := B0 xor Key[0];
  T01 := B1 xor Key[1];
  T02 := B2 xor Key[2];
  T03 := B3 xor Key[3];
  // performing transformation 9 times
  // round 1
  T10 := F0[T00 and $ff] xor F1[(T01 shr 8) and $ff] xor
    F2[(T02 shr 16) and $ff] xor F3[(T03 shr 24) and $ff] xor Key[4];
  T11 := F0[T01 and $ff] xor F1[(T02 shr 8) and $ff] xor
    F2[(T03 shr 16) and $ff] xor F3[(T00 shr 24) and $ff] xor Key[5];
  T12 := F0[T02 and $ff] xor F1[(T03 shr 8) and $ff] xor
    F2[(T00 shr 16) and $ff] xor F3[(T01 shr 24) and $ff] xor Key[6];
  T13 := F0[T03 and $ff] xor F1[(T00 shr 8) and $ff] xor
    F2[(T01 shr 16) and $ff] xor F3[(T02 shr 24) and $ff] xor Key[7];
  // round 2
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[8];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[9];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[10];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[11];
  // round 3
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[12];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[13];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[14];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[15];
  // round 4
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[16];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[17];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[18];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[19];
  // round 5
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[20];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[21];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[22];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[23];
  // round 6
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[24];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[25];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[26];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[27];
  // round 7
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[28];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[29];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[30];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[31];
  // round 8
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[32];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[33];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[34];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[35];
  // round 9
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[36];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[37];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[38];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[39];
  // last round of transformations
  B0 := LF[Byte(T10)] xor (LF[Byte(T11 shr 8)] shl 8) xor
    (LF[Byte(T12 shr 16)] shl 16) xor (LF[Byte(T13 shr 24)] shl 24) xor Key[40];
  B1 := LF[Byte(T11)] xor (LF[Byte(T12 shr 8)] shl 8) xor
    (LF[Byte(T13 shr 16)] shl 16) xor (LF[Byte(T10 shr 24)] shl 24) xor Key[41];
  B2 := LF[Byte(T12)] xor (LF[Byte(T13 shr 8)] shl 8) xor
    (LF[Byte(T10 shr 16)] shl 16) xor (LF[Byte(T11 shr 24)] shl 24) xor Key[42];
  B3 := LF[Byte(T13)] xor (LF[Byte(T10 shr 8)] shl 8) xor
    (LF[Byte(T11 shr 16)] shl 16) xor (LF[Byte(T12 shr 24)] shl 24) xor Key[43];
end;

procedure Encrypt192(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey192);
var
  T00, T01, T02, T03, T10, T11, T12, T13 : LongWord;
begin
  // initializing
  T00 := B0 xor Key[0];
  T01 := B1 xor Key[1];
  T02 := B2 xor Key[2];
  T03 := B3 xor Key[3];
  // performing transformation 11 times
  // round 1
  T10 := F0[T00 and $ff] xor F1[(T01 shr 8) and $ff] xor
    F2[(T02 shr 16) and $ff] xor F3[(T03 shr 24) and $ff] xor Key[4];
  T11 := F0[T01 and $ff] xor F1[(T02 shr 8) and $ff] xor
    F2[(T03 shr 16) and $ff] xor F3[(T00 shr 24) and $ff] xor Key[5];
  T12 := F0[T02 and $ff] xor F1[(T03 shr 8) and $ff] xor
    F2[(T00 shr 16) and $ff] xor F3[(T01 shr 24) and $ff] xor Key[6];
  T13 := F0[T03 and $ff] xor F1[(T00 shr 8) and $ff] xor
    F2[(T01 shr 16) and $ff] xor F3[(T02 shr 24) and $ff] xor Key[7];
  // round 2
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[8];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[9];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[10];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[11];
  // round 3
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[12];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[13];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[14];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[15];
  // round 4
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[16];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[17];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[18];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[19];
  // round 5
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[20];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[21];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[22];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[23];
  // round 6
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[24];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[25];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[26];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[27];
  // round 7
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[28];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[29];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[30];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[31];
  // round 8
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[32];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[33];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[34];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[35];
  // round 9
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[36];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[37];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[38];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[39];
  // round 10
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[40];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[41];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[42];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[43];
  // round 11
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[44];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[45];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[46];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[47];
  // last round of transformations
  B0 := LF[Byte(T10)] xor (LF[Byte(T11 shr 8)] shl 8) xor
    (LF[Byte(T12 shr 16)] shl 16) xor (LF[Byte(T13 shr 24)] shl 24) xor Key[48];
  B1 := LF[Byte(T11)] xor (LF[Byte(T12 shr 8)] shl 8) xor
    (LF[Byte(T13 shr 16)] shl 16) xor (LF[Byte(T10 shr 24)] shl 24) xor Key[49];
  B2 := LF[Byte(T12)] xor (LF[Byte(T13 shr 8)] shl 8) xor
    (LF[Byte(T10 shr 16)] shl 16) xor (LF[Byte(T11 shr 24)] shl 24) xor Key[50];
  B3 := LF[Byte(T13)] xor (LF[Byte(T10 shr 8)] shl 8) xor
    (LF[Byte(T11 shr 16)] shl 16) xor (LF[Byte(T12 shr 24)] shl 24) xor Key[51];
end;

procedure Encrypt256(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey256);
var
  T00, T01, T02, T03, T10, T11, T12, T13 : LongWord;
begin
  // initializing
  T00 := B0 xor Key[0];
  T01 := B1 xor Key[1];
  T02 := B2 xor Key[2];
  T03 := B3 xor Key[3];
  // performing transformation 13 times
  // round 1
  T10 := F0[T00 and $ff] xor F1[(T01 shr 8) and $ff] xor
    F2[(T02 shr 16) and $ff] xor F3[(T03 shr 24) and $ff] xor Key[4];
  T11 := F0[T01 and $ff] xor F1[(T02 shr 8) and $ff] xor
    F2[(T03 shr 16) and $ff] xor F3[(T00 shr 24) and $ff] xor Key[5];
  T12 := F0[T02 and $ff] xor F1[(T03 shr 8) and $ff] xor
    F2[(T00 shr 16) and $ff] xor F3[(T01 shr 24) and $ff] xor Key[6];
  T13 := F0[T03 and $ff] xor F1[(T00 shr 8) and $ff] xor
    F2[(T01 shr 16) and $ff] xor F3[(T02 shr 24) and $ff] xor Key[7];
  // round 2
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[8];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[9];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[10];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[11];
  // round 3
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[12];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[13];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[14];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[15];
  // round 4
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[16];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[17];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[18];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[19];
  // round 5
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[20];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[21];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[22];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[23];
  // round 6
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[24];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[25];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[26];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[27];
  // round 7
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[28];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[29];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[30];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[31];
  // round 8
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[32];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[33];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[34];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[35];
  // round 9
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[36];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[37];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[38];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[39];
  // round 10
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[40];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[41];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[42];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[43];
  // round 11
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[44];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[45];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[46];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[47];
  // round 12
  T00 := F0[Byte(T10)] xor F1[Byte(T11 shr 8)] xor
    F2[Byte(T12 shr 16)] xor F3[Byte(T13 shr 24)] xor Key[48];
  T01 := F0[Byte(T11)] xor F1[Byte(T12 shr 8)] xor
    F2[Byte(T13 shr 16)] xor F3[Byte(T10 shr 24)] xor Key[49];
  T02 := F0[Byte(T12)] xor F1[Byte(T13 shr 8)] xor
    F2[Byte(T10 shr 16)] xor F3[Byte(T11 shr 24)] xor Key[50];
  T03 := F0[Byte(T13)] xor F1[Byte(T10 shr 8)] xor
    F2[Byte(T11 shr 16)] xor F3[Byte(T12 shr 24)] xor Key[51];
  // round 13
  T10 := F0[Byte(T00)] xor F1[Byte(T01 shr 8)] xor
    F2[Byte(T02 shr 16)] xor F3[Byte(T03 shr 24)] xor Key[52];
  T11 := F0[Byte(T01)] xor F1[Byte(T02 shr 8)] xor
    F2[Byte(T03 shr 16)] xor F3[Byte(T00 shr 24)] xor Key[53];
  T12 := F0[Byte(T02)] xor F1[Byte(T03 shr 8)] xor
    F2[Byte(T00 shr 16)] xor F3[Byte(T01 shr 24)] xor Key[54];
  T13 := F0[Byte(T03)] xor F1[Byte(T00 shr 8)] xor
    F2[Byte(T01 shr 16)] xor F3[Byte(T02 shr 24)] xor Key[55];
  // last round of transformations
  B0 := LF[Byte(T10)] xor (LF[Byte(T11 shr 8)] shl 8) xor
    (LF[Byte(T12 shr 16)] shl 16) xor (LF[Byte(T13 shr 24)] shl 24) xor Key[56];
  B1 := LF[Byte(T11)] xor (LF[Byte(T12 shr 8)] shl 8) xor
    (LF[Byte(T13 shr 16)] shl 16) xor (LF[Byte(T10 shr 24)] shl 24) xor Key[57];
  B2 := LF[Byte(T12)] xor (LF[Byte(T13 shr 8)] shl 8) xor
    (LF[Byte(T10 shr 16)] shl 16) xor (LF[Byte(T11 shr 24)] shl 24) xor Key[58];
  B3 := LF[Byte(T13)] xor (LF[Byte(T10 shr 8)] shl 8) xor
    (LF[Byte(T11 shr 16)] shl 16) xor (LF[Byte(T12 shr 24)] shl 24) xor Key[59];
end;

procedure Decrypt128(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey128);
var
  T00, T01, T02, T03, T10, T11, T12, T13 : LongWord;
begin
  // initializing
  T00 := B0 xor Key[40];
  T01 := B1 xor Key[41];
  T02 := B2 xor Key[42];
  T03 := B3 xor Key[43];

  // performing transformations 9 times
  // round 1
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[36];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[37];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[38];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[39];
  // round 2
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[32];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[33];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[34];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[35];
  // round 3
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[28];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[29];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[30];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[31];
  // round 4
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[24];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[25];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[26];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[27];
  // round 5
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[20];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[21];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[22];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[23];
  // round 6
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[16];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[17];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[18];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[19];
  // round 7
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[12];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[13];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[14];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[15];
  // round 8
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[8];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[9];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[10];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[11];
  // round 9
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[4];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[5];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[6];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[7];
  // last round of transformations
  B0 := LFInv[Byte(T10)] xor (LFInv[Byte(T13 shr 8)] shl 8) xor
    (LFInv[Byte(T12 shr 16)] shl 16) xor (LFInv[Byte(T11 shr 24)] shl 24) xor Key[0];
  B1 := LFInv[Byte(T11)] xor (LFInv[Byte(T10 shr 8)] shl 8) xor
    (LFInv[Byte(T13 shr 16)] shl 16) xor (LFInv[Byte(T12 shr 24)] shl 24) xor Key[1];
  B2 := LFInv[Byte(T12)] xor (LFInv[Byte(T11 shr 8)] shl 8) xor
    (LFInv[Byte(T10 shr 16)] shl 16) xor (LFInv[Byte(T13 shr 24)] shl 24) xor Key[2];
  B3 := LFInv[Byte(T13)] xor (LFInv[Byte(T12 shr 8)] shl 8) xor
    (LFInv[Byte(T11 shr 16)] shl 16) xor (LFInv[Byte(T10 shr 24)] shl 24) xor Key[3];
end;

procedure Decrypt192(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey192);
var
  T00, T01, T02, T03, T10, T11, T12, T13 : LongWord;
begin
  // initializing
  T00 := B0 xor Key[48];
  T01 := B1 xor Key[49];
  T02 := B2 xor Key[50];
  T03 := B3 xor Key[51];
  
  // performing transformations 11 times
  // round 1
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[44];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[45];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[46];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[47];
  // round 2
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[40];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[41];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[42];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[43];
  // round 3
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[36];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[37];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[38];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[39];
  // round 4
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[32];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[33];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[34];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[35];
  // round 5
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[28];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[29];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[30];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[31];
  // round 6
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[24];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[25];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[26];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[27];
  // round 7
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[20];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[21];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[22];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[23];
  // round 8
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[16];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[17];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[18];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[19];
  // round 9
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[12];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[13];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[14];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[15];
  // round 10
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[8];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[9];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[10];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[11];
  // round 11
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[4];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[5];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[6];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[7];
  // last round of transformations
  B0 := LFInv[Byte(T10)] xor (LFInv[Byte(T13 shr 8)] shl 8) xor
    (LFInv[Byte(T12 shr 16)] shl 16) xor (LFInv[Byte(T11 shr 24)] shl 24) xor Key[0];
  B1 := LFInv[Byte(T11)] xor (LFInv[Byte(T10 shr 8)] shl 8) xor
    (LFInv[Byte(T13 shr 16)] shl 16) xor (LFInv[Byte(T12 shr 24)] shl 24) xor Key[1];
  B2 := LFInv[Byte(T12)] xor (LFInv[Byte(T11 shr 8)] shl 8) xor
    (LFInv[Byte(T10 shr 16)] shl 16) xor (LFInv[Byte(T13 shr 24)] shl 24) xor Key[2];
  B3 := LFInv[Byte(T13)] xor (LFInv[Byte(T12 shr 8)] shl 8) xor
    (LFInv[Byte(T11 shr 16)] shl 16) xor (LFInv[Byte(T10 shr 24)] shl 24) xor Key[3];
end;

procedure Decrypt256(var B0, B1, B2, B3 : LongWord; const Key: TAESExpandedKey256);
var
  T00, T01, T02, T03, T10, T11, T12, T13 : LongWord;
begin
  // initializing
  T00 := B0 xor Key[56];
  T01 := B1 xor Key[57];
  T02 := B2 xor Key[58];
  T03 := B3 xor Key[59];

  // performing transformations 13 times
  // round 1
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[52];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[53];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[54];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[55];
  // round 2
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[48];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[49];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[50];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[51];
  // round 3
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[44];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[45];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[46];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[47];
  // round 4
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[40];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[41];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[42];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[43];
  // round 5
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[36];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[37];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[38];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[39];
  // round 6
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[32];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[33];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[34];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[35];
  // round 7
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[28];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[29];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[30];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[31];
  // round 8
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[24];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[25];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[26];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[27];
  // round 9
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[20];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[21];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[22];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[23];
  // round 10
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[16];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[17];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[18];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[19];
  // round 11
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[12];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[13];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[14];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[15];
  // round 12
  T00 := FInv0[Byte(T10)] xor FInv1[Byte(T13 shr 8)] xor
    FInv2[Byte(T12 shr 16)] xor FInv3[Byte(T11 shr 24)] xor Key[8];
  T01 := FInv0[Byte(T11)] xor FInv1[Byte(T10 shr 8)] xor
    FInv2[Byte(T13 shr 16)] xor FInv3[Byte(T12 shr 24)] xor Key[9];
  T02 := FInv0[Byte(T12)] xor FInv1[Byte(T11 shr 8)] xor
    FInv2[Byte(T10 shr 16)] xor FInv3[Byte(T13 shr 24)] xor Key[10];
  T03 := FInv0[Byte(T13)] xor FInv1[Byte(T12 shr 8)] xor
    FInv2[Byte(T11 shr 16)] xor FInv3[Byte(T10 shr 24)] xor Key[11];
  // round 13
  T10 := FInv0[Byte(T00)] xor FInv1[Byte(T03 shr 8)] xor
    FInv2[Byte(T02 shr 16)] xor FInv3[Byte(T01 shr 24)] xor Key[4];
  T11 := FInv0[Byte(T01)] xor FInv1[Byte(T00 shr 8)] xor
    FInv2[Byte(T03 shr 16)] xor FInv3[Byte(T02 shr 24)] xor Key[5];
  T12 := FInv0[Byte(T02)] xor FInv1[Byte(T01 shr 8)] xor
    FInv2[Byte(T00 shr 16)] xor FInv3[Byte(T03 shr 24)] xor Key[6];
  T13 := FInv0[Byte(T03)] xor FInv1[Byte(T02 shr 8)] xor
    FInv2[Byte(T01 shr 16)] xor FInv3[Byte(T00 shr 24)] xor Key[7];
  // last round of transformations
  B0 := LFInv[Byte(T10)] xor (LFInv[Byte(T13 shr 8)] shl 8) xor
    (LFInv[Byte(T12 shr 16)] shl 16) xor (LFInv[Byte(T11 shr 24)] shl 24) xor Key[0];
  B1 := LFInv[Byte(T11)] xor (LFInv[Byte(T10 shr 8)] shl 8) xor
    (LFInv[Byte(T13 shr 16)] shl 16) xor (LFInv[Byte(T12 shr 24)] shl 24) xor Key[1];
  B2 := LFInv[Byte(T12)] xor (LFInv[Byte(T11 shr 8)] shl 8) xor
    (LFInv[Byte(T10 shr 16)] shl 16) xor (LFInv[Byte(T13 shr 24)] shl 24) xor Key[2];
  B3 := LFInv[Byte(T13)] xor (LFInv[Byte(T12 shr 8)] shl 8) xor
    (LFInv[Byte(T11 shr 16)] shl 16) xor (LFInv[Byte(T10 shr 24)] shl 24) xor Key[3];
end;

end.
